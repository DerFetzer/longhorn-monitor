// Package apiserver provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apiserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// PodHealth defines model for PodHealth.
type PodHealth struct {
	ErrorCount int32  `json:"errorCount"`
	IsDeleted  bool   `json:"isDeleted"`
	IsHealthy  bool   `json:"isHealthy"`
	Namespace  string `json:"namespace"`
	PodName    string `json:"podName"`
}

// DeleteHealthParams defines parameters for DeleteHealth.
type DeleteHealthParams struct {

	// Name of the pod
	PodName string `json:"podName"`

	// Namespace the pod is in
	Namespace string `json:"namespace"`
}

// PostHealthParams defines parameters for PostHealth.
type PostHealthParams struct {

	// Is the pod healthy?
	IsHealthy bool `json:"isHealthy"`

	// Name of the pod
	PodName string `json:"podName"`

	// Namespace the pod is in
	Namespace string `json:"namespace"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Delete pod health entry
	// (DELETE /podHealth)
	DeleteHealth(ctx echo.Context, params DeleteHealthParams) error
	// Get pod health status entries
	// (GET /podHealth)
	GetHealth(ctx echo.Context) error
	// Update pod health status entry
	// (POST /podHealth)
	PostHealth(ctx echo.Context, params PostHealthParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// DeleteHealth converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteHealth(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteHealthParams
	// ------------- Required query parameter "podName" -------------

	err = runtime.BindQueryParameter("form", true, true, "podName", ctx.QueryParams(), &params.PodName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter podName: %s", err))
	}

	// ------------- Required query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, true, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteHealth(ctx, params)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// PostHealth converts echo context to params.
func (w *ServerInterfaceWrapper) PostHealth(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostHealthParams
	// ------------- Required query parameter "isHealthy" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHealthy", ctx.QueryParams(), &params.IsHealthy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHealthy: %s", err))
	}

	// ------------- Required query parameter "podName" -------------

	err = runtime.BindQueryParameter("form", true, true, "podName", ctx.QueryParams(), &params.PodName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter podName: %s", err))
	}

	// ------------- Required query parameter "namespace" -------------

	err = runtime.BindQueryParameter("form", true, true, "namespace", ctx.QueryParams(), &params.Namespace)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter namespace: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostHealth(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.DELETE("/podHealth", wrapper.DeleteHealth)
	router.GET("/podHealth", wrapper.GetHealth)
	router.POST("/podHealth", wrapper.PostHealth)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9xUTW/UQAz9K5HhGHbTj1MufEqlAkqFxKnqYZo4m2mT8dTjIIVq/zvyZElnaSpWHLll",
	"Yo+f/d7zPEBFvSeHTgKUDxCqFnsTPy+p/oimk1YPnskji8UYQmbi9zQ40VND3BuBEqyTk2PIQUaP0xE3",
	"yLDNwYYP2KFgrfm78A1Rh8ZN4QlpXA4702PwpsIkHISt22jUU31h+qXYNgfG+8Gy4l7NiWnBFDtP50p7",
	"vp5HoptbrAS2Wtq6hhS0Iiemikxgb2wHJdzprzt5UyO/alB+Iq9q1F7FSqd1PpPbtMQu+0LOCjHk8AM5",
	"WHJQQrE6WhWaTR6d8RZKOFkVqwJy8EbaqMDap+rUsVH9UpWMWHLnNZQwDbDL09tsehTkAOWV3goVWy8T",
	"qlKTUZNJi5mnWgnQ3/cD8rijDMqEw0dmhQfMd85ZVGEJKtL/GyyzIbPuGchUrMNBrzU5eHJhsuxxUUxM",
	"pY18/aQ0ny6F3pk6+4b3AwaZck6f5lyQZA0Nro5WC0PfGx5n2uNgbeQ+Qyc8ap0NylOZzlBmjZaaVofh",
	"tGvG+85W8er6NmgXDwkJVrCPF18yNlDCi/Xjdq93q71+3Ovt7GvDbMbJ1vsjvs06G0R98cc0+hIcxN0e",
	"M2coaaEgRoaQ1vMUFgi6pCCHufg8zJ6aMMbXz9gq3fu/2mp+jJbN/F/vzdG/782e9t99bfa3IpE/mm/7",
	"KwAA//9yVwYGjgYAAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

